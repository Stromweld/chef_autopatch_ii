#
# Dynamically generated by Chef on <%= node["fqdn"] %>
# Local modifications will be overwritten by Chef.
#
# Powershell 2.0
# Copyright (c) 2008-2013 RightScale, Inc, All Rights Reserved Worldwide.

# regex filter for updates. All matching updates will be filtered out and not installed. | (pipe) is OR operator.
# To match multiple updates in the title use keywords like "Malicious|KB44" to match any update with the word Malicious and all updates with KB ID starting with KB44 anywhere in their titles.
$reg = "<%= node['autopatch_ii']['updates_to_skip'] %>"

# Stop and fail script when a command fails.
$errorActionPreference = "Stop"
$global:logFile = ""

function WriteHostAndLogFile
{
  Param([String]$message)
  Add-Content $global:logFile -Value "$((Get-Date).ToString('yyyy-MM-ddTHH:mm:ss:fff')) - $message"
  Write-Host "$((Get-Date).ToString('yyyy-MM-ddTHH:mm:ss:fff')) - $message"
}

function WriteWarningAndLogFile
{
  Param([String]$message)
  Add-Content $global:logFile -Value "$((Get-Date).ToString('yyyy-MM-ddTHH:mm:ss:fff')) - WARN: $message"
  Write-Warning "$((Get-Date).ToString('yyyy-MM-ddTHH:mm:ss:fff')) - WARN: $message"
}

function WriteErrorAndLogFile
{
  Param([String]$message)
  Add-Content $global:logFile -Value "$((Get-Date).ToString('yyyy-MM-ddTHH:mm:ss:fff')) - ERROR: $message"
  Write-Error "$((Get-Date).ToString('yyyy-MM-ddTHH:mm:ss:fff')) - ERROR: $message"
}

function CreateLogFileAndCleanupOldLogs
{
  $logsPath = $PSScriptRoot #PS 3.0+
  $global:logFile = "$($logsPath)\autopatchlog_$(Get-Date -f yyyyMMdd).log"
  if (!(Test-Path $global:logFile)) # test for existence
  {
    Write-Host "Creating log file: $($global:logFile)"
    New-Item -Path $global:logFile -ItemType file
  }

  WriteHostAndLogFile "Cleaning up old logs from path: $($logsPath)"

  # Keep Current (just created) + 1
  $allOldLogFiles = Get-ChildItem -Path $logsPath -ErrorAction 'Stop' | Where-Object {$_.Name.StartsWith("autopatchlog")} | sort LastWriteTime -Descending | select -Skip 2

  # If we have any old ones, delete 'em.
  if($allOldLogFiles -ne $null -and $allOldLogFiles.Count -gt 0)
  {
    foreach($oldFile in $allOldLogFiles)
    {
      WriteHostAndLogFile "Removing $($oldFile.FullName)."
      Remove-Item $oldFile.FullName -Force
    }
  }
}

function SendEmailNotificationIfRequired
{
  Param($someErrorOccurred, $manualRebootRequired, $bodyMessage)
  $mailNotificationMode = "<%= node['autopatch_ii']['email_notification_mode'] %>"

  $mailNotificationRequired = (($mailNotificationMode -eq "Always") -or ($mailNotificationMode -eq "OnlyOnErrorOrManualReboot" -and ($someErrorOccurred -or $manualRebootRequired)))
  if($mailNotificationRequired)
  {
    $mailToAddresses = <%= node['autopatch_ii']['email_to_addresses'] %>
    $mailSubject = "AutoPatch ran."
    $mailPriority = [System.Net.Mail.MailPriority]::Normal
    $mailBody = "$($bodyMessage)`n`nFull log attached"

    if($manualRebootRequired)
    {
      $mailSubject = "$($mailSubject) RebootRequired: Yes"
    }
    else
    {
      $mailSubject = "$($mailSubject) RebootRequired: No"
    }

    if($someErrorOccurred)
    {
      $mailPriority = [System.Net.Mail.MailPriority]::High
      $mailBody = "AN ERROR OCCURRED. See full attached log for details.`n`n$($mailBody)"
      $mailSubject = "$($mailSubject) Errors: Yes"
    }
    else
    {
      $mailSubject = "$($mailSubject) Errors: No"
    }

    Send-MailMessage -From "<%= node['autopatch_ii']['email_from_address'] %>" -To $mailToAddresses -Subject $mailSubject -Body $mailBody -SmtpServer "paw2al-smtprl01.teamfreeze.com" -Priority $mailPriority -Attachments $global:logFile
  }
  else
  {
    WriteHostAndLogFile "No email notification sent due to notification mode $mailNotificationMode and error occurrence, $someErrorOccurred, or manual reboot required, $manualRebootRequired"
  }
}

# Main Logic
try
{
  Write-Host "Starting script..."
  CreateLogFileAndCleanupOldLogs

  <% if node['autopatch_ii']['download_install_splay_max_seconds'] > 0 -%>
  # We don't want all servers that are running this script to search, download, install, and reboot at the same time.
  $downloadAndInstallSplayInSec = Get-Random -Maximum <%= node['autopatch_ii']['download_install_splay_max_seconds'] %> -Minimum 1
  WriteHostAndLogFile ("Download and Install Splay is enabled. Will search, start downloading and installing in {0:N0} seconds, which is at $((Get-Date).AddSeconds($downloadAndInstallSplayInSec).ToString('g'))" -f $downloadAndInstallSplayInSec)
  Start-Sleep -s $downloadAndInstallSplayInSec
  <% else -%>
  WriteHostAndLogFile "Download and Install Splay is disabled. Will start searching for new updates now."
  <% end -%>

  $UpdatesToDownload = New-Object -ComObject "Microsoft.Update.UpdateColl"
  $objServiceManager = New-Object -ComObject "Microsoft.Update.ServiceManager" #Support local instance only
  $objSession = New-Object -ComObject "Microsoft.Update.Session" #Support local instance only
  $objSearcher = $objSession.CreateUpdateSearcher()
  $search = "IsInstalled = 0"
  WriteHostAndLogFile "Searching for new updates..."
  try
  {
    $objResults = New-Object -ComObject "Microsoft.Update.UpdateColl"
    $notInstalled = $objSearcher.Search($search)
    foreach ($temp in $notInstalled.Updates)
    {
      if ($reg -eq "")
      {
        $objResults.Add($temp) | Out-Null
      }
      else
      {
        if ($temp.Title -notmatch $reg)
        {
          $objResults.Add($temp) | Out-Null
        }
      }
    }
  }
  catch
  {
    if($_ -match "HRESULT: 0x80072EE2")
    {
      WriteWarningAndLogFile "Error searching for updates (HRESULT: 0x80072EE2) - connection to update server failed."
    } #End If $_ -match "HRESULT: 0x80072EE2"
    throw "An error occurred while search for updates to be installed."
  } #End Catch
  if ($objResults.Updates.Count -eq 0)
  {
    WriteHostAndLogFile "Found $($notInstalled.Updates.Count) new updates."
    WriteHostAndLogFile "Found $($objResults.Count) after filter applied"
    WriteHostAndLogFile "No selected updates found to be installed."
    SendEmailNotificationIfRequired -someErrorOccurred $false -bodyMessage "No new updates." -manualRebootRequired $false
    Exit 0
  }
  else
  {
    # There are updates to be installed.
    WriteHostAndLogFile "Found $($notInstalled.Updates.Count) new updates."
    WriteHostAndLogFile "Found $($objResults.Count) after filter applied."
    foreach ($update in $objResults)
    {
      WriteHostAndLogFile "Update to install '$($update.Title)'"
    }
  }
  # === Download Updates ===
  WriteHostAndLogFile "Starting download of updates..."
  $updDownloader = $objSession.CreateUpdateDownloader()
  $DownloadedUpdateCollection = New-Object -ComObject "Microsoft.Update.UpdateColl"
  $FailedToDownloadUpdate = New-Object -ComObject "Microsoft.Update.UpdateColl"
  $EulaAcceptapceRequire = New-Object -ComObject "Microsoft.Update.UpdateColl"
  foreach ($update in $objResults.Updates)
  {
    $objCollectionTmp = New-Object -ComObject "Microsoft.Update.UpdateColl"
    $objCollectionTmp.Add($Update) | Out-Null
    $Downloader = $objSession.CreateUpdateDownloader()
    $Downloader.Updates = $objCollectionTmp
    try
    {
      Write-Debug "Try download update"
      $DownloadResult = $Downloader.Download()
    } #End try
    catch
    {
      if($_ -match "HRESULT: 0x80240044")
      {
        WriteWarningAndLogFile "HRESULT: 0x80240044 - permission denied. Please check your security policy."
      } #End If $_ -match "HRESULT: 0x80240044"
      throw "An error occurred while downloading an update."
    } #End Catch
    Write-Debug "Check ResultCode"
    Switch -exact ($DownloadResult.ResultCode)
    {
      0   { $Status = "NotStarted" }
      1   { $Status = "InProgress" }
      2   { $Status = "Downloaded" }
      3   { $Status = "DownloadedWithErrors" }
      4   { $Status = "Failed" }
      5   { $Status = "Aborted" }
    } #End Switch
    if(($DownloadResult.ResultCode -eq 2) -and ($($update.EulaAccepted) -eq $true))
    {
      Write-Debug "Update KB$($update.KBArticleIDs) was successfully downloaded"
      $DownloadedUpdateCollection.Add($Update) | Out-Null
    } #End If $DownloadResult.ResultCode -eq 2 -and $($update.EulaAccepted) -eq $true)
    if(($DownloadResult.ResultCode -eq 2) -and ($($update.EulaAccepted) -eq $false))
    {
      WriteHostAndLogFile "Update KB($($update.KBArticleIDs)) requires user accept EULA. This update will be only downloaded, but not installed. You can install it manually."
      $EulaAcceptapceRequire.Add($Update) | Out-Null
    }#End If $DownloadResult.ResultCode -eq 2 -and $($update.EulaAccepted) -eq $false)
    if ($DownloadResult.ResultCode -ne 2)
    {
      WriteHostAndLogFile "Downloading Update KB$($update.KBArticleIDs) failed with status $Status ."
      $FailedToDownloadUpdate.Add($Update)
    }
  }
  if ($EulaAcceptapceRequire.Count -ne 0)
  {
    WriteHostAndLogFile "The following updates were downloaded but not installed because they require to accept EULA before installation:"
    foreach ($Update in $EulaAcceptapceRequire)
    {
      WriteHostAndLogFile "KB$($Update.KBArticleIDs)"
    }
  }
  if ($FailedToDownloadUpdate.Count -ne 0)
  {
    WriteHostAndLogFile "The following updates failed to download:"
    foreach ($update in $FailedToDownloadUpdate)
    {
      WriteHostAndLogFile "KB$($update.KBArticleIDs)"
    }
  }
  if ($DownloadedUpdateCollection.Count -eq 0)
  {
    Throw "No updates were downloaded."
  }
  else
  {
    WriteHostAndLogFile "Updates to install:"
    foreach ($update in $DownloadedUpdateCollection)
    {
      WriteHostAndLogFile "KB$($update.KBArticleIDs)"
    }

  }

  #-==Install Update==-
  WriteHostAndLogFile "Now installing downloaded updates..."
  $NeedsReboot=$false
  $AnyUpdateFailed=$false
  $UpdateInstallationFailed = New-Object -ComObject "Microsoft.Update.UpdateColl"
  $UpdateInstallationReboot = New-Object -ComObject "Microsoft.Update.UpdateColl"
  foreach ($update in $DownloadedUpdateCollection)
  {

    $objCollectionTmp = New-Object -ComObject "Microsoft.Update.UpdateColl"
    $objCollectionTmp.Add($Update) | Out-Null

    $objInstaller = $objSession.CreateUpdateInstaller()
    $objInstaller.Updates = $objCollectionTmp
    try
    {
      Write-Debug "Trying to install update KB$($update.KBArticleIDs).."
      $InstallResult = $objInstaller.Install()
    } #End Try
    catch
    {
      WriteWarningAndLogFile "Error installing update KB$($update.KBArticleIDs)."
      if($_ -match "HRESULT: 0x80240044")
      {
        WriteWarningAndLogFile "HRESULT: 0x80240044 - permission denied. Please check your security policy."
      } #End If $_ -match "HRESULT: 0x80240044"
      throw "Error installing update KB$($update.KBArticleIDs)."
    } #End Catch
    if ($InstallResult.ResultCode -ne 2)
    {
      $Status = "Unknown"
      Switch -exact ($InstallResult.ResultCode)
      {
        0   { $Status = "NotStarted"}
        1   { $Status = "InProgress"}
        2   { $Status = "Installed"}
        3   { $Status = "InstalledWithErrors"}
        4   { $Status = "Failed"}
        5   { $Status = "Aborted"}
      }
      WriteHostAndLogFile "Update Installation Failed with $Status"
      $AnyUpdateFailed=$true
      $UpdateInstallationFailed.Add($update)
    }
    if ($InstallResult.ResultCode -eq 2)
    {
      WriteHostAndLogFile "Update KB$($update.KBArticleIDs) installation successfully completed"
      if ($($Update.RebootRequired) -eq $true)
      {
        WriteHostAndLogFile "KB$($update.KBArticleIDs) requires reboot to be applied."
        $UpdateInstallationReboot.Add($update)
      }
    }
    # if any update from collection require reboot, then mark sign NeedsReboot as true
    if (($NeedsReboot -eq $false) -and ($($Update.RebootRequired) -eq $true))
    {
      $NeedsReboot = $Update.RebootRequired
    }
  }

  if ($UpdateInstallationFailed.Count -ne 0)
  {
    WriteHostAndLogFile "Installation of the following updates failed:"
    foreach ($Update in $UpdateInstallationFailed)
    {
      WriteHostAndLogFile "KB$($Update.KBArticleIDs)"
    }
  }
  if ($UpdateInstallationReboot -ne 0)
  {
    WriteHostAndLogFile "Updates that require reboot to take effect:"
    foreach ($update in $UpdateInstallationReboot)
    {
      WriteHostAndLogFile "KB$($update.KBArticleIDs)"
    }
  }
  if($NeedsReboot) #checks if any update requires reboot after installation
  {
    $AutoRebootAllowed = $<%= node['autopatch_ii']['auto_reboot_enabled'] %>
    if($AutoRebootAllowed)
    {
      Remove-Item <%= "#{Chef::Config[:file_cache_path]}\\autopatch.txt" %>
      WriteHostAndLogFile "Reboot is required, and Auto reboot is allowed on this machine. Rebooting NOW!"
      SendEmailNotificationIfRequired -someErrorOccurred $AnyUpdateFailed -manualRebootRequired $false -bodyMessage "Reboot is required, and Auto reboot is allowed on this machine. Rebooting NOW!"
      Restart-Computer -Force
    } #End If $AutoReboot
    else
    {
      Remove-Item <%= "#{Chef::Config[:file_cache_path]}\\autopatch.txt" %>
      WriteHostAndLogFile "Manual reboot required! AutoReboot is NOT allowed on this machine."
      SendEmailNotificationIfRequired -someErrorOccurred $AnyUpdateFailed -manualRebootRequired $true -bodyMessage "Manual reboot required."
      return "Reboot is required, but not allowed by settings. Please do the reboot manually."
    } #End Else $AutoReboot If $IgnoreReboot
  } #End If $NeedsReboot
  else
  {
    Remove-Item <%= "#{Chef::Config[:file_cache_path]}\\autopatch.txt" %>
    WriteHostAndLogFile "Reboot is not required."
    SendEmailNotificationIfRequired -someErrorOccurred $AnyUpdateFailed -manualRebootRequired $false -bodyMessage "No reboot required."
  }
}
catch
{
  Remove-Item <%= "#{Chef::Config[:file_cache_path]}\\autopatch.txt" %>
  WriteErrorAndLogFile $Error[0]
  WriteErrorAndLogFile ($Error[0].ErrorRecord.Exception | gm)
  SendEmailNotificationIfRequired -someErrorOccurred $true -bodyMessage "Unexpected Error!!" -manualRebootRequired $false
  Exit 1
}
