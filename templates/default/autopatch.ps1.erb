#
# Dynamically generated by Chef on <%= node["fqdn"] %>
# Local modifications will be overwritten by Chef.
#
# Powershell 2.0
# Copyright (c) 2008-2013 RightScale, Inc, All Rights Reserved Worldwide.

# Stop and fail script when a command fails.
$errorActionPreference = "Stop"
$global:logFile = ""

function WriteHostAndLogFile
{
    Param([String]$message)
    Add-Content $global:logFile -Value "$((Get-Date).ToString('yyyy-MM-ddTHH:mm:ss:fff')) - $message"
    Write-Host "$((Get-Date).ToString('yyyy-MM-ddTHH:mm:ss:fff')) - $message" 
}

function WriteWarningAndLogFile
{
    Param([String]$message)
    Add-Content $global:logFile -Value "$((Get-Date).ToString('yyyy-MM-ddTHH:mm:ss:fff')) - WARN: $message"
    Write-Warning "$((Get-Date).ToString('yyyy-MM-ddTHH:mm:ss:fff')) - WARN: $message"
}

function WriteErrorAndLogFile
{
    Param([String]$message)
    Add-Content $global:logFile -Value "$((Get-Date).ToString('yyyy-MM-ddTHH:mm:ss:fff')) - ERROR: $message"
    Write-Error "$((Get-Date).ToString('yyyy-MM-ddTHH:mm:ss:fff')) - ERROR: $message"
}

function CreateLogFileAndCleanupOldLogs
{
    $logsPath = $PSScriptRoot #PS 3.0+
    $global:logFile = "$($logsPath)\autopatchlog_$(Get-Date -f yyyyMMdd).log"
    if (!(Test-Path $global:logFile)) # test for existence
    { 
        Write-Host "Creating log file: $($global:logFile)"
        New-Item -Path $global:logFile -ItemType file 
    }

    WriteHostAndLogFile "Cleaning up old logs from path: $($logsPath)"

    # Keep Current (just created) + 1    
    $allOldLogFiles = Get-ChildItem -Path $logsPath -ErrorAction 'Stop' | Where-Object {$_.Name.StartsWith("autopatchlog")} | sort LastWriteTime -Descending | select -Skip 2
    
    # If we have any old ones, delete 'em.
    if($allOldLogFiles -ne $null -and $allOldLogFiles.Count -gt 0)
    {
        foreach($oldFile in $allOldLogFiles)
        {
            WriteHostAndLogFile "Removing $($oldFile.FullName)."
            Remove-Item $oldFile.FullName -Force
        }
    }
}

function SendEmailNotificationIfRequired
{
    Param($someErrorOccurred, $manualRebootRequired, $bodyMessage)
    $mailNotificationMode = "<%= node['autopatch_ii']['email_notification_mode'] %>"

    $mailNotificationRequired = (($mailNotificationMode -eq "Always") -or ($mailNotificationMode -eq "OnlyOnErrorOrManualReboot" -and ($someErrorOccurred -or $manualRebootRequired)))
    if($mailNotificationRequired)
    {
        $mailToAddresses = <%= node['autopatch_ii']['email_to_addresses'] %>
        $mailSubject = "AutoPatch ran."
        $mailPriority = [System.Net.Mail.MailPriority]::Normal
        $mailBody = "$($bodyMessage)`n`nFull log attached"

        if($manualRebootRequired)
        {
            $mailSubject = "$($mailSubject) RebootRequired: Yes"
        }
        else
        {
            $mailSubject = "$($mailSubject) RebootRequired: No"
        }

        if($someErrorOccurred)
        {
            $mailPriority = [System.Net.Mail.MailPriority]::High
            $mailBody = "AN ERROR OCCURRED. See full attached log for details.`n`n$($mailBody)"
            $mailSubject = "$($mailSubject) Errors: Yes"
        }
        else
        {
            $mailSubject = "$($mailSubject) Errors: No"
        }
        
       Send-MailMessage -From "<%= node['autopatch_ii']['email_from_address'] %>" -To $mailToAddresses -Subject $mailSubject -Body $mailBody -SmtpServer "paw2al-smtprl01.teamfreeze.com" -Priority $mailPriority -Attachments $global:logFile
    }
    else
    {
        WriteHostAndLogFile "No email notification sent due to notification mode $mailNotificationMode and error occurrence, $someErrorOccurred, or manual reboot required, $manualRebootRequired"
    }
}

# Main Logic
try
{
    Write-Host "Starting script..."
    CreateLogFileAndCleanupOldLogs
    
  <% if node['autopatch_ii']['download_install_splay_max_seconds'] > 0 -%>
    # We don't want all servers that are running this script to search, download, install, and reboot at the same time.
    $downloadAndInstallSplayInSec = Get-Random -Maximum <%= node['autopatch_ii']['download_install_splay_max_seconds'] %> -Minimum 1
    WriteHostAndLogFile ("Download and Install Splay is enabled. Will search, start downloading and installing in {0:N0} seconds, which is at $((Get-Date).AddSeconds($downloadAndInstallSplayInSec).ToString('g'))" -f $downloadAndInstallSplayInSec)
    Start-Sleep -s $downloadAndInstallSplayInSec
  <% else -%>
    WriteHostAndLogFile "Download and Install Splay is disabled. Will start searching for new updates now."
  <% end -%>

    $UpdatesToDownload = New-Object -ComObject "Microsoft.Update.UpdateColl"
    $objServiceManager = New-Object -ComObject "Microsoft.Update.ServiceManager" #Support local instance only
    $objSession = New-Object -ComObject "Microsoft.Update.Session" #Support local instance only
    $objSearcher = $objSession.CreateUpdateSearcher()
    $search = "IsInstalled = 0"
    WriteHostAndLogFile "Searching for new updates..."
    try
    {
        $objResults = $objSearcher.Search($search)
    }
    catch
    {
        if($_ -match "HRESULT: 0x80072EE2")
        {
            WriteWarningAndLogFile "Error searching for updates (HRESULT: 0x80072EE2) - connection to update server failed."
        } #End If $_ -match "HRESULT: 0x80072EE2"
        throw "An error occurred while search for updates to be installed."
    } #End Catch
    if ($objResults.Updates.Count -eq 0)
    {
        WriteHostAndLogFile "No new updates found. Your system is up to date."
        SendEmailNotificationIfRequired -someErrorOccurred $false -bodyMessage "No new updates." -manualRebootRequired $false
        Exit 0
    }
    else
    {
        # There are updates to be installed.
        WriteHostAndLogFile "Found $($objResults.Updates.Count) new updates."
        WriteHostAndLogFile "Starting download and install NOW!!"
    }
    # === Download Updates ===
    $updDownloader = $objSession.CreateUpdateDownloader()
    $DownloadedUpdateCollection = New-Object -ComObject "Microsoft.Update.UpdateColl" 
    $FailedToDownloadUpdate = New-Object -ComObject "Microsoft.Update.UpdateColl"
    $EulaAcceptapceRequire = New-Object -ComObject "Microsoft.Update.UpdateColl"
    foreach ($update in $objResults.Updates)
    {
        $objCollectionTmp = New-Object -ComObject "Microsoft.Update.UpdateColl"
        $objCollectionTmp.Add($Update) | Out-Null
        $Downloader = $objSession.CreateUpdateDownloader() 
        $Downloader.Updates = $objCollectionTmp
        try
        {
            Write-Debug "Try download update"
            $DownloadResult = $Downloader.Download()
        } #End try
        catch
        {
            if($_ -match "HRESULT: 0x80240044")
            {
                WriteWarningAndLogFile "HRESULT: 0x80240044 - permission denied. Please check your security policy."
            } #End If $_ -match "HRESULT: 0x80240044"
            throw "An error occurred while downloading an update."
        } #End Catch 
        Write-Debug "Check ResultCode"
        Switch -exact ($DownloadResult.ResultCode)
        {
            0   { $Status = "NotStarted" }
            1   { $Status = "InProgress" }
            2   { $Status = "Downloaded" }
            3   { $Status = "DownloadedWithErrors" }
            4   { $Status = "Failed" }
            5   { $Status = "Aborted" }
        } #End Switch
        if(($DownloadResult.ResultCode -eq 2) -and ($($update.EulaAccepted) -eq $true))
        {
            Write-Debug "Update KB$($update.KBArticleIDs) was successfully downloaded"
            $DownloadedUpdateCollection.Add($Update) | Out-Null
        } #End If $DownloadResult.ResultCode -eq 2 -and $($update.EulaAccepted) -eq $true)
        if(($DownloadResult.ResultCode -eq 2) -and ($($update.EulaAccepted) -eq $false))
        {
            WriteHostAndLogFile "Update KB($($update.KBArticleIDs)) requires user accept EULA. This update will be only downloaded, but not installed. You can install it manually."
            $EulaAcceptapceRequire.Add($Update) | Out-Null
        }#End If $DownloadResult.ResultCode -eq 2 -and $($update.EulaAccepted) -eq $false)
        if ($DownloadResult.ResultCode -ne 2)
        {
            WriteHostAndLogFile "Downloading Update KB$($update.KBArticleIDs) failed with status $Status ."
            $FailedToDownloadUpdate.Add($Update)
        }
    }
    if ($EulaAcceptapceRequire.Count -ne 0)
    {   
        WriteHostAndLogFile "The following updates were downloaded but not installed because they require to accept EULA before installation:"
        foreach ($Update in $EulaAcceptapceRequire)
        {
            WriteHostAndLogFile "KB$($Update.KBArticleIDs)"
        }
    }
    if ($FailedToDownloadUpdate.Count -ne 0)
    {   
        WriteHostAndLogFile "The following updates failed to download:"
        foreach ($update in $FailedToDownloadUpdate)
        {
            WriteHostAndLogFile "KB$($update.KBArticleIDs)"
        }
    }
    if ($DownloadedUpdateCollection.Count -eq 0)
    {
        Throw "No updates were downloaded."
    } 
    else
    {
        WriteHostAndLogFile "Updates to install:"
        foreach ($update in $DownloadedUpdateCollection)
        {
            WriteHostAndLogFile "KB$($update.KBArticleIDs)"
        }
        
    }   
 
    #-==Install Update==-
    WriteHostAndLogFile "Now installing downloaded updates..."
    $NeedsReboot=$false
    $AnyUpdateFailed=$false
    $UpdateInstallationFailed = New-Object -ComObject "Microsoft.Update.UpdateColl" 
    $UpdateInstallationReboot = New-Object -ComObject "Microsoft.Update.UpdateColl" 
    foreach ($update in $DownloadedUpdateCollection)
    {   
        
        $objCollectionTmp = New-Object -ComObject "Microsoft.Update.UpdateColl"
        $objCollectionTmp.Add($Update) | Out-Null

        $objInstaller = $objSession.CreateUpdateInstaller()
        $objInstaller.Updates = $objCollectionTmp
        try
        {
            Write-Debug "Trying to install update KB$($update.KBArticleIDs).."
            $InstallResult = $objInstaller.Install()
        } #End Try
        catch
        {
            WriteWarningAndLogFile "Error installing update KB$($update.KBArticleIDs)."
            if($_ -match "HRESULT: 0x80240044")
            {
                WriteWarningAndLogFile "HRESULT: 0x80240044 - permission denied. Please check your security policy."
            } #End If $_ -match "HRESULT: 0x80240044"
            throw "Error installing update KB$($update.KBArticleIDs)."
        } #End Catch
        if ($InstallResult.ResultCode -ne 2)
        {   
            $Status = "Unknown"
            Switch -exact ($InstallResult.ResultCode)
            {
                0   { $Status = "NotStarted"}
                1   { $Status = "InProgress"}
                2   { $Status = "Installed"}
                3   { $Status = "InstalledWithErrors"}
                4   { $Status = "Failed"}
                5   { $Status = "Aborted"}
            }
            WriteHostAndLogFile "Update Installation Failed with $Status"
            $AnyUpdateFailed=$true
            $UpdateInstallationFailed.Add($update)
        }
        if ($InstallResult.ResultCode -eq 2)
        {
            WriteHostAndLogFile "Update KB$($update.KBArticleIDs) installation successfully completed"
            if ($($Update.RebootRequired) -eq $true)
            { 
                WriteHostAndLogFile "KB$($update.KBArticleIDs) requires reboot to be applied."
                $UpdateInstallationReboot.Add($update)
            }
        }
        # if any update from collection require reboot, then mark sign NeedsReboot as true
        if (($NeedsReboot -eq $false) -and ($($Update.RebootRequired) -eq $true))
        {
            $NeedsReboot = $Update.RebootRequired
        }
    }

    if ($UpdateInstallationFailed.Count -ne 0)
    {   
        WriteHostAndLogFile "Installation of the following updates failed:"
        foreach ($Update in $UpdateInstallationFailed)
        {
            WriteHostAndLogFile "KB$($Update.KBArticleIDs)"
        }
    }
    if ($UpdateInstallationReboot -ne 0)
    {
        WriteHostAndLogFile "Updates that require reboot to take effect:"
        foreach ($update in $UpdateInstallationReboot)
        {
            WriteHostAndLogFile "KB$($update.KBArticleIDs)"
        }
    }
    if($NeedsReboot) #checks if any update requires reboot after installation
    {
        $AutoRebootAllowed = $<%= node['autopatch_ii']['auto_reboot_enabled'] %>
        if($AutoRebootAllowed)
        {
            Remove-Item <%= "#{Chef::Config[:file_cache_path]}\\autopatch.txt" %>
            WriteHostAndLogFile "Reboot is required, and Auto reboot is allowed on this machine. Rebooting NOW!"
            SendEmailNotificationIfRequired -someErrorOccurred $AnyUpdateFailed -manualRebootRequired $false -bodyMessage "Reboot is required, and Auto reboot is allowed on this machine. Rebooting NOW!"
            Restart-Computer -Force
        } #End If $AutoReboot
        else
        {
            Remove-Item <%= "#{Chef::Config[:file_cache_path]}\\autopatch.txt" %>
            WriteHostAndLogFile "Manual reboot required! AutoReboot is NOT allowed on this machine."
            SendEmailNotificationIfRequired -someErrorOccurred $AnyUpdateFailed -manualRebootRequired $true -bodyMessage "Manual reboot required."
            return "Reboot is required, but not allowed by settings. Please do the reboot manually."
        } #End Else $AutoReboot If $IgnoreReboot
    } #End If $NeedsReboot
    else
    {
        Remove-Item <%= "#{Chef::Config[:file_cache_path]}\\autopatch.txt" %>
        WriteHostAndLogFile "Reboot is not required."
        SendEmailNotificationIfRequired -someErrorOccurred $AnyUpdateFailed -manualRebootRequired $false -bodyMessage "No reboot required."
    }
}
catch
{
    Remove-Item <%= "#{Chef::Config[:file_cache_path]}\\autopatch.txt" %>
    WriteErrorAndLogFile $Error[0]
    WriteErrorAndLogFile ($Error[0].ErrorRecord.Exception | gm)
    SendEmailNotificationIfRequired -someErrorOccurred $true -bodyMessage "Unexpected Error!!" -manualRebootRequired $false
    Exit 1
}
